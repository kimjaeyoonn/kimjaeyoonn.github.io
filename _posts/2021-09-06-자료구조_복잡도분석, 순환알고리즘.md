# 알고리즘 성능 분석법

> 어떻게 알고리즘의 성능을 표기할 것인지.

- 알고리즘 성증 분석 기법
  - 시간 복잡도 분석 : **수행 시간** 분석
  - 공간 복잡도 분석  : 수행시 필요로 하는 **메모리 공간** 분석



- 시간 복잡도 분석, 어떻게 할 것인가 ?

  : 실행시간 직접 측정 방법 : 알고리즘의 종료시간과 시작시간의 차이를 계산하여 분석한다.

  - 단점

    - 여러개의 알고리즘이 있을 때 각각의 구현이 필요하며, 어려울 수 있다.

    - 두 알고리즘을 비교하려면 동일한 환경으로 맞춰줘야 한다.

이러한 단점들을 극복하기 위해 직접 측정하는 등 실험에 의한 방법이 아닌, 다른 예측 방식으로 알고리즘 성능 분석



- 복잡도 분석 (예측 방법)
  - 실제로 구현하지 않고도 시간복잡도를 알아낼 수 있다.
  - 가능한 모든 input 조합들을 고려할 수 있다.
  - 입력 개수 n에 대한 함수를 통해 계산
  - Big - O Notation : 차수가 가장 큰 항이 절대적인 영향을 미친다.

<img src="C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20210906152109515.png" alt="image-20210906152109515" style="zoom: 67%;" />

- Big - Omega Notation 와 Big - Theta Notation

![image-20210909233643672](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20210909233643672.png)

- 성능과 관련하여...

  - 최선의 경우

    : 수행 시간이 가장 빠른 경우를 말한다. 일반적으로 크게 의미는 없다.

  - 평균의 경우

    : 수행시간이 평균적인 경우를 말한다. 모든 케이스를 알아야지 평균을 계산할 수 있기 때문에 계산하기 어렵다.

  - **최악의 경우**

    : 수행 시간이 가장 늦은 경우를 말한다. 최대 얼마의 시간이 걸리는지 알게 되었을 때, 그 시간을 기반으로 다른 무언가를 할 수 있기 때문에 중요한 의미를 가진다.





# 순환 (Recursion) 알고리즘

> 알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법
>
> 정의 자체가 순환적으로 되어 있는 경우에 적합하다. (ex. 팩토리얼, 피보나치 수열, 이항계수, 이진탐색)

- Recursion vs Repetition
  - 순환(Recursion) : 순환적인 문제에서는 자연스러운 방법. 함수 호출의 오버헤드 = 스택구조 (단점).
  - 반복(Repetition) : for, while 문 이용. 수행 속도 빠름. 순환적인 문제에서 프로그램 작성이 어려울 수 있음.

순환 방식이 유리할 때도 있지만, 아닐 때도 있다. / 대부분의 순환은 반복으로 바꾸어 작성할 수 있다.

- 순환이 더 빠른 예 
  - 거듭제곱 x^n 계산
    - 순환적인 함수의 시간 복잡도 : 𝑶(𝒍𝒐𝒈𝟐𝒏)
    - 반복적인 함수의 시간 복잡도 : 𝑶(𝒏)



![image-20210910001847911](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20210910001847911.png)

- 순환이 더 느린 예
  - 피보나치 수열의 계산
    - 순환적인 함수의 시간 복잡도 : 𝑶(𝟐𝒏) (같은 항이 중복 계산 되어 효율성이 떨어지게 된다.)
    - 반복적인 함수의 시간 복잡도 : 𝑶(𝒏)



- 하노이탑 문제를 해결하는 프로그램을 순환을 이용하여 구현하시오 ... ?

  입력 : 원판의 수 n

  